#!/bin/bash
# mount_zo - Helper script to mount Zo Computer workspace

set -e

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RESET='\033[0m'
BOLD='\033[1m'

# Configuration
ZO_MOUNT_PORT=0
ZO_MOUNT_POINT="$HOME/zoMount"
SERVER_SCRIPT="$(dirname "$0")/zoMount"

# Use Windows-compatible temp directory if on Windows
if [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "win32" ]]; then
    # Windows - use TEMP environment variable
    if [ -n "$TEMP" ]; then
        LOG_FILE="$TEMP/zoMount.log"
        PID_FILE="$TEMP/zoMount.pid"
    else
        LOG_FILE="/tmp/zoMount.log"
        PID_FILE="/tmp/zoMount.pid"
    fi
else
    LOG_FILE="/tmp/zoMount.log"
    PID_FILE="/tmp/zoMount.pid"
fi

# Detect OS
detect_os() {
    local uname_out="$(uname -s)"
    case "${uname_out}" in
        Linux*)     echo "linux";;
        Darwin*)    echo "macos";;
        CYGWIN*)    echo "windows";;
        MINGW*)     echo "windows";;
        MSYS*)      echo "windows";;
        *)          echo "unknown";;
    esac
}

# Check if server is running on detected port
is_server_running() {
    local port=$1
    if [ -z "$port" ]; then
        return 1
    fi
    curl -s -o /dev/null -w "%{http_code}" http://localhost:$port/ 2>/dev/null | grep -q "200\|301\|302\|401"
}

# Check if we're running inside Zo Computer environment
check_zo_computer_environment() {
    # Check if we're in the workspace directory
    if [[ "$PWD" == /home/workspace* ]]; then
        return 0
    fi
    
    # Check for Zo Computer specific paths
    if [ -d "/home/workspace" ] || [ -d "/__substrate" ]; then
        return 0
    fi
    
    # Check hostname patterns
    if [[ "$(hostname)" == *"zo.computer"* ]]; then
        return 0
    fi
    
    # Not in Zo Computer environment
    return 1
}


# Start WebDAV server
start_server() {
    echo -e "${CYAN}Starting WebDAV server...${RESET}"
    
    # Check if server already running
    if ps aux | grep "[p]ython.*zoMount" > /dev/null 2>&1; then
        echo -e "${GREEN}✓ Server already running${RESET}"
        # Extract port from existing log
        if [ -f "$LOG_FILE" ]; then
            ZO_MOUNT_PORT=$(grep -o "localhost:[0-9]*" "$LOG_FILE" 2>/dev/null | grep -o "[0-9]*" | head -1)
            if [ -n "$ZO_MOUNT_PORT" ]; then
                echo -e "${GREEN}✓ Port: $ZO_MOUNT_PORT${RESET}"
                return 0
            fi
        fi
        # If can't get port from log, assume 9999
        ZO_MOUNT_PORT=9999
        return 0
    fi
    
    # Detect Python command
    PYTHON_CMD=""
    if command -v py &> /dev/null; then
        PYTHON_CMD="py"
    elif command -v python3 &> /dev/null; then
        PYTHON_CMD="python3"
    elif command -v python &> /dev/null; then
        PYTHON_CMD="python"
    else
        echo -e "${RED}Error: Python is not installed${RESET}"
        echo "Install from: https://www.python.org/downloads/"
        exit 1
    fi
    
    # Check if dependencies are installed
    if ! $PYTHON_CMD -c "import wsgidav" 2>/dev/null; then
        echo -e "${YELLOW}Installing dependencies...${RESET}"
        $PYTHON_CMD -m pip install wsgidav cheroot requests || {
            echo -e "${RED}Failed to install dependencies${RESET}"
            echo "Try manually: $PYTHON_CMD -m pip install wsgidav cheroot requests"
            exit 1
        }
    fi
    
    # Start server in background
    echo -e "${YELLOW}Starting Python server...${RESET}"
    
    # Clean up old logs
    rm -f "$LOG_FILE" "$PID_FILE"
    
    # Start server with output redirection
    $PYTHON_CMD -u "$SERVER_SCRIPT" > "$LOG_FILE" 2>&1 &
    SERVER_PID=$!
    echo $SERVER_PID > "$PID_FILE"
    
    echo -e "${DIM}PID: $SERVER_PID${RESET}"
    echo -e "${DIM}Log: $LOG_FILE${RESET}"
    
    # Wait for server to start
    echo -e "${YELLOW}Waiting for server...${RESET}"
    
    for i in {1..10}; do
        sleep 1
        
        # Check if process still alive
        if ! kill -0 $SERVER_PID 2>/dev/null; then
            echo -e "${RED}✗ Server process died${RESET}"
            if [ -f "$LOG_FILE" ]; then
                echo -e "${YELLOW}Last 20 lines of log:${RESET}"
                tail -20 "$LOG_FILE"
            fi
            exit 1
        fi
        
        # Try to extract port from log
        if [ -f "$LOG_FILE" ]; then
            PORT=$(grep -o "localhost:[0-9]*" "$LOG_FILE" 2>/dev/null | grep -o "[0-9]*" | head -1)
            if [ -n "$PORT" ]; then
                ZO_MOUNT_PORT=$PORT
                # Verify server responds
                if curl -s -o /dev/null -w "%{http_code}" "http://localhost:$PORT/" 2>/dev/null | grep -q "200\|301\|302\|401"; then
                    echo -e "${GREEN}✓ Server running on port $PORT${RESET}"
                    return 0
                fi
            fi
        fi
    done
    
    # Final fallback - check if server is on port 9999
    if curl -s -o /dev/null -w "%{http_code}" "http://localhost:9999/" 2>/dev/null | grep -q "200\|301\|302\|401"; then
        ZO_MOUNT_PORT=9999
        echo -e "${GREEN}✓ Server running on port 9999${RESET}"
        return 0
    fi
    
    echo -e "${RED}✗ Server failed to start${RESET}"
    echo "Check logs: cat \"$LOG_FILE\""
    exit 1
}
mount_filesystem() {
    local os=$(detect_os)
    
    echo -e "${CYAN}Mounting workspace...${RESET}"
    
    # Create mount point if it doesn't exist
    mkdir -p "$ZO_MOUNT_POINT"
    
    case $os in
        macos)
            # macOS uses mount_webdav
            if mount | grep -q "$ZO_MOUNT_POINT"; then
                echo -e "${YELLOW}Already mounted at $ZO_MOUNT_POINT${RESET}"
                return 0
            fi
            
            mount_webdav -s http://localhost:$ZO_MOUNT_PORT "$ZO_MOUNT_POINT" 2>/dev/null || {
                echo -e "${RED}✗ Mount failed${RESET}"
                echo "Try manually: mount_webdav http://localhost:$ZO_MOUNT_PORT $ZO_MOUNT_POINT"
                exit 1
            }
            ;;
            
        linux)
            # Linux uses davfs2
            if ! command -v mount.davfs &> /dev/null; then
                echo -e "${YELLOW}Installing davfs2...${RESET}"
                sudo apt-get update && sudo apt-get install -y davfs2 || {
                    echo -e "${RED}Failed to install davfs2${RESET}"
                    echo "Install manually: sudo apt-get install davfs2"
                    exit 1
                }
            fi
            
            if mount | grep -q "$ZO_MOUNT_POINT"; then
                echo -e "${YELLOW}Already mounted at $ZO_MOUNT_POINT${RESET}"
                return 0
            fi
            
            # Configure davfs2 to skip authentication (our server doesn't use HTTP auth)
            DAVFS_CONF="/tmp/zoMount_davfs.conf"
            cat > "$DAVFS_CONF" << 'EOF'
# Temporary davfs2 config for zoMount
use_locks 0
ask_auth 0
secrets /tmp/zoMount_secrets
EOF
            
            # Create empty secrets file
            touch /tmp/zoMount_secrets
            chmod 600 /tmp/zoMount_secrets
            
            # Mount using davfs2 with custom config
            echo -e "${YELLOW}Mounting (you may need to enter sudo password)...${RESET}"
            
            # Set trap to cleanup on failure
            cleanup_on_fail() {
                echo -e "${RED}Mount failed, cleaning up...${RESET}"
                # Kill the server we just started
                if [ -f /tmp/zoMount.pid ]; then
                    PID=$(cat /tmp/zoMount.pid)
                    kill $PID 2>/dev/null || true
                    rm /tmp/zoMount.pid 2>/dev/null || true
                fi
            }
            
            if ! sudo mount -t davfs -o conf="$DAVFS_CONF",uid=$(id -u),gid=$(id -g) \
                http://localhost:$ZO_MOUNT_PORT "$ZO_MOUNT_POINT" 2>&1; then
                cleanup_on_fail
                echo -e "${RED}✗ Mount failed${RESET}"
                echo ""
                echo -e "${YELLOW}Troubleshooting:${RESET}"
                echo "1. Check server logs: tail /tmp/zoMount.log"
                echo "2. Make sure server is running: curl http://localhost:9999/"
                echo "3. Try restarting: ./mount_zo unmount && ./mount_zo mount"
                exit 1
            fi
            ;;
            
        windows)
            # Windows uses net use with WebClient service
            echo -e "${CYAN}Checking WebClient service...${RESET}"
            
            # Check if WebClient service is running
            if ! sc query WebClient | grep -q "RUNNING"; then
                echo -e "${YELLOW}Starting WebClient service...${RESET}"
                net start WebClient 2>/dev/null || {
                    echo -e "${RED}Failed to start WebClient service${RESET}"
                    echo "Run as Administrator: net start WebClient"
                    exit 1
                }
            fi
            
            # Check Registry for BasicAuthLevel (Required for HTTP WebDAV)
            echo -e "${CYAN}Checking Windows Registry...${RESET}"
            REG_CHECK=$(reg query "HKLM\SYSTEM\CurrentControlSet\Services\WebClient\Parameters" //v BasicAuthLevel 2>/dev/null | grep "0x2")
            if [ -z "$REG_CHECK" ]; then
                echo -e "${YELLOW}⚠ Warning: Windows restricts WebDAV over HTTP by default.${RESET}"
                echo -e "${YELLOW}You need to set BasicAuthLevel to 2 in the Registry.${RESET}"
                echo ""
                echo -e "${BOLD}Run this command in Administrator PowerShell:${RESET}"
                echo -e "Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\WebClient\Parameters' -Name 'BasicAuthLevel' -Value 2"
                echo -e "Restart-Service WebClient"
                echo ""
                echo -e "Attempting to mount anyway..."
            fi
            
            echo -e "${CYAN}Mounting to Z: drive...${RESET}"
            
            # Validate port before attempting mount
            if [ -z "$ZO_MOUNT_PORT" ] || [ "$ZO_MOUNT_PORT" -eq 0 ] 2>/dev/null; then
                echo -e "${RED}✗ Invalid port detected: '$ZO_MOUNT_PORT'${RESET}"
                echo -e "${YELLOW}Server may have started but port detection failed.${RESET}"
                echo "Check logs: cat \"$LOG_FILE\""
                exit 1
            fi
            
            # Use 127.0.0.1 instead of localhost (more reliable on Windows)
            MOUNT_URL="http://127.0.0.1:$ZO_MOUNT_PORT"
            echo -e "${DIM}Mount URL: $MOUNT_URL${RESET}"
            
            # Try to mount
            # Note: We use empty username/password to prevent prompt
            if net use Z: "$MOUNT_URL" /user:dummy dummy 2>&1 | tee /tmp/mount_output.txt | grep -q "successfully\|command completed"; then
                # Verify mount actually worked
                sleep 2
                if net use | grep -q "Z:"; then
                    ZO_MOUNT_POINT="Z:"
                    echo -e "${GREEN}✓ Successfully mounted to Z:${RESET}"
                    
                    # Test if we can actually list files
                    if ls Z: > /dev/null 2>&1; then
                        echo -e "${GREEN}✓ Mount verified - files accessible${RESET}"
                    else
                        echo -e "${YELLOW}⚠ Mount succeeded but files not immediately accessible${RESET}"
                        echo -e "${DIM}Try: dir Z:${RESET}"
                    fi
                else
                    echo -e "${RED}✗ Mount command succeeded but drive not visible${RESET}"
                    cat /tmp/mount_output.txt
                    exit 1
                fi
            else
                echo -e "${RED}✗ Mount failed${RESET}"
                echo ""
                echo -e "${YELLOW}Error output:${RESET}"
                cat /tmp/mount_output.txt
                echo ""
                echo -e "${YELLOW}Troubleshooting:${RESET}"
                echo "1. Registry: Ensure BasicAuthLevel is set to 2 (see warning above)"
                echo "2. Service: Ensure WebClient is running"
                echo "3. Manual: net use Z: $MOUNT_URL /user:dummy dummy"
                exit 1
            fi
            ;;
            
        *)
            echo -e "${RED}Unsupported OS${RESET}"
            exit 1
            ;;
    esac
    
    echo ""
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "${GREEN}✓ Workspace successfully mounted!${RESET}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
    echo -e "  Mount point: ${BOLD}$ZO_MOUNT_POINT${RESET}"
    echo -e "  Server: http://localhost:$ZO_MOUNT_PORT"
    echo ""
}

# Unmount filesystem
unmount_filesystem() {
    local os=$(detect_os)
    
    echo -e "${CYAN}Unmounting workspace...${RESET}"
    
    case $os in
        macos)
            if mount | grep -q "$ZO_MOUNT_POINT"; then
                umount "$ZO_MOUNT_POINT" 2>/dev/null || {
                    echo -e "${RED}✗ Unmount failed${RESET}"
                    exit 1
                }
            fi
            ;;
            
        linux)
            if mount | grep -q "$ZO_MOUNT_POINT"; then
                sudo umount "$ZO_MOUNT_POINT" 2>/dev/null || {
                    echo -e "${RED}✗ Unmount failed${RESET}"
                    exit 1
                }
            fi
            ;;
            
        windows)
            net use Z: /delete 2>/dev/null || true
            ;;
    esac
    
    echo -e "${GREEN}✓ Unmounted${RESET}"
}

# Stop server
stop_server() {
    if [ -f /tmp/zoMount.pid ]; then
        PID=$(cat /tmp/zoMount.pid)
        if ps -p $PID > /dev/null 2>&1; then
            echo -e "${CYAN}Stopping server (PID: $PID)...${RESET}"
            kill $PID 2>/dev/null || true
            rm /tmp/zoMount.pid
            echo -e "${GREEN}✓ Server stopped${RESET}"
        fi
    fi
}

# Main command handler
case "${1:-mount}" in
    mount)
        # Check if we're running inside Zo Computer
        if check_zo_computer_environment; then
            clear
            echo -e "${RED}"
            cat << "ERROR"
     ██████╗ ██╗  ██╗    ███╗   ██╗ ██████╗ 
    ██╔═══██╗██║  ██║    ████╗  ██║██╔═══██╗
    ██║   ██║███████║    ██╔██╗ ██║██║   ██║
    ██║   ██║██╔══██║    ██║╚██╗██║██║   ██║
    ╚██████╔╝██║  ██║    ██║ ╚████║╚██████╔╝
     ╚═════╝ ╚═╝  ╚═╝    ╚═╝  ╚═══╝ ╚═════╝ 
ERROR
            echo -e "${RESET}"
            echo ""
            echo -e "${BOLD}${RED}Cannot Mount From Zo Computer VPS!${RESET}"
            echo ""
            echo -e "${YELLOW}This feature is designed for mounting your Zo Computer workspace"
            echo -e "onto your ${BOLD}local machine${RESET}${YELLOW} (Windows, macOS, Linux laptop/desktop).${RESET}"
            echo ""
            echo -e "You are currently ${RED}inside${RESET} your Zo Computer VPS environment."
            echo -e "Mounting the workspace onto itself doesn't make sense!"
            echo ""
            echo -e "${CYAN}To use this feature:${RESET}"
            echo -e "  1. Exit your SSH session (type 'exit')"
            echo -e "  2. Run zochat on your ${BOLD}local machine${RESET}"
            echo -e "  3. Select [8] Mount"
            echo ""
            exit 1
        fi
        
        if is_server_running; then
            echo -e "${GREEN}Server is already running${RESET}"
        else
            start_server
        fi
        mount_filesystem
        echo ""
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo -e "${BOLD}  Zo Computer workspace mounted!${RESET}"
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
        echo ""
        echo -e "  ${CYAN}Mount point:${RESET} $ZO_MOUNT_POINT"
        echo -e "  ${CYAN}Status:${RESET}      $(mount | grep $ZO_MOUNT_POINT | head -1)"
        echo ""
        echo -e "${YELLOW}To unmount:${RESET} ./mount_zo unmount"
        echo ""
        ;;
        
    unmount)
        unmount_filesystem
        stop_server
        ;;
        
    status)
        if is_server_running; then
            echo -e "${GREEN}✓ Server is running on port $ZO_MOUNT_PORT${RESET}"
            if mount | grep -q "$ZO_MOUNT_POINT"; then
                echo -e "${GREEN}✓ Mounted at $ZO_MOUNT_POINT${RESET}"
            else
                echo -e "${YELLOW}⚠ Server running but not mounted${RESET}"
            fi
        else
            echo -e "${RED}✗ Server is not running${RESET}"
        fi
        ;;
        
    *)
        echo "Usage: $0 {mount|unmount|status}"
        exit 1
        ;;
esac
