#!/usr/bin/env python3
"""
zoMount - WebDAV server for mounting Zo Computer workspace
"""

import os
import sys
import json
import requests
from datetime import datetime
from wsgidav.wsgidav_app import WsgiDAVApp
from wsgidav.dav_provider import DAVProvider, DAVCollection, DAVNonCollection
from wsgidav.dav_error import DAVError, HTTP_NOT_FOUND, HTTP_FORBIDDEN

class ZoFile(DAVNonCollection):
    """Represents a file in the Zo Computer workspace"""
    
    def __init__(self, path, environ, file_info):
        super().__init__(path, environ)
        self.file_info = file_info
        self.name = file_info.get("name", os.path.basename(path))
        
    def get_content_length(self):
        return self.file_info.get("size", 0)
    
    def get_content_type(self):
        # Simple MIME type detection based on extension
        ext = os.path.splitext(self.name)[1].lower()
        mime_types = {
            '.txt': 'text/plain',
            '.md': 'text/markdown',
            '.py': 'text/x-python',
            '.js': 'text/javascript',
            '.json': 'application/json',
            '.html': 'text/html',
            '.css': 'text/css',
            '.jpg': 'image/jpeg',
            '.png': 'image/png',
            '.pdf': 'application/pdf',
        }
        return mime_types.get(ext, 'application/octet-stream')
    
    def get_creation_date(self):
        return None  # Could parse from API if available
    
    def get_last_modified(self):
        return None  # Could parse from API if available
    
    def get_content(self):
        """Download file content from Zo Computer"""
        provider = self.provider
        domain = provider.domain
        access_token = provider.access_token
        
        # Try to download file content
        # We'll try multiple possible endpoints
        file_path = self.path.lstrip('/')
        
        endpoints = [
            f"https://{domain}/api/workspace-file?path={file_path}",
            f"https://{domain}/api/file?path={file_path}",
            f"https://{domain}/files/download?path={file_path}",
        ]
        
        for endpoint in endpoints:
            try:
                response = requests.get(
                    endpoint,
                    headers={
                        'Cookie': f'access_token={access_token}',
                        'Origin': f'https://{domain}'
                    },
                    timeout=10
                )
                
                if response.status_code == 200:
                    return response.content
                    
            except Exception as e:
                continue
        
        # If all endpoints fail, return empty content
        return b""
    
    def support_ranges(self):
        return False
    
    def begin_write(self, content_type=None):
        """Begin writing content to file"""
        return ZoFileWriter(self)
    
    def delete(self):
        """Delete this file"""
        provider = self.provider
        domain = provider.domain
        access_token = provider.access_token
        
        # Get path parts for API call
        file_path = self.path.lstrip('/')
        path_parts = file_path.split('/') if file_path else []
        
        try:
            # Move to trash
            response = requests.post(
                f"https://{domain}/api/move-to-trash",
                headers={
                    'Cookie': f'access_token={access_token}',
                    'Origin': f'https://{domain}',
                    'Content-Type': 'application/json'
                },
                json=path_parts,
                timeout=10
            )
            
            if response.status_code == 200:
                # Clear cache for parent directory
                parent_path = os.path.dirname(self.path)
                if parent_path in provider.cache:
                    del provider.cache[parent_path]
                return True
            else:
                print(f"Delete failed: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"Error deleting file: {e}")
            return False


class ZoFileWriter:
    """Handles writing content to a Zo Computer file"""
    
    def __init__(self, file_resource):
        self.file_resource = file_resource
        self.buffer = bytearray()
    
    def write(self, data):
        """Write data to buffer"""
        self.buffer.extend(data)
    
    def close(self):
        """Upload buffered content to Zo Computer"""
        provider = self.file_resource.provider
        domain = provider.domain
        access_token = provider.access_token
        file_path = self.file_resource.path.lstrip('/')
        
        # Parse path into parent parts and filename
        path_parts = file_path.split('/') if file_path else []
        filename = path_parts[-1] if path_parts else "untitled"
        parent_parts = path_parts[:-1] if len(path_parts) > 1 else []
        
        try:
            # Step 1: Create file entry
            create_response = requests.post(
                f"https://{domain}/api/create-file",
                headers={
                    'Cookie': f'access_token={access_token}',
                    'Origin': f'https://{domain}',
                    'Content-Type': 'application/json'
                },
                json={
                    'parentPathParts': parent_parts,
                    'name': filename,
                    'type': 'file',
                    'root': 'w'
                },
                timeout=10
            )
            
            if create_response.status_code != 200:
                print(f"Create file failed: {create_response.status_code}")
                return
            
            # Step 2: Upload file content
            files = {
                'file': (filename, bytes(self.buffer), 'application/octet-stream')
            }
            
            upload_response = requests.post(
                f"https://{domain}/api/file-uploads/single",
                headers={
                    'Cookie': f'access_token={access_token}',
                    'Origin': f'https://{domain}'
                },
                files=files,
                timeout=30
            )
            
            if upload_response.status_code == 200:
                # Clear cache for parent directory to refresh listing
                parent_path = os.path.dirname(self.file_resource.path) or '/'
                if parent_path in provider.cache:
                    del provider.cache[parent_path]
                print(f"Successfully uploaded: {filename}")
            else:
                print(f"Upload failed: {upload_response.status_code}")
                
        except Exception as e:
            print(f"Error writing file: {e}")


class ZoDirectory(DAVCollection):
    """Represents a directory in the Zo Computer workspace"""
    
    def __init__(self, path, environ, dir_info):
        super().__init__(path, environ)
        self.dir_info = dir_info
        self.name = dir_info.get("name", os.path.basename(path.rstrip('/')))
    
    def get_member_names(self):
        """Return list of child names"""
        children = self.dir_info.get("children", [])
        return [child["name"] for child in children]
    
    def get_member(self, name):
        """Return a child resource by name"""
        children = self.dir_info.get("children", [])
        
        for child in children:
            if child["name"] == name:
                child_path = os.path.join(self.path, name).replace('\\', '/')
                
                if child["type"] == "directory":
                    # Fetch subdirectory info
                    sub_info = self.provider.get_directory_info(child_path)
                    if sub_info:
                        return ZoDirectory(child_path, self.environ, sub_info)
                else:
                    return ZoFile(child_path, self.environ, child)
        
        return None
    
    def create_member(self, name, is_collection=False):
        """Create a new file or directory"""
        if is_collection:
            # Create directory
            return self.create_collection(name)
        else:
            # Create file - return a new ZoFile instance that doesn't exist yet
            child_path = os.path.join(self.path, name).replace('\\', '/')
            file_info = {
                "name": name,
                "type": "file",
                "size": 0
            }
            return ZoFile(child_path, self.environ, file_info)
    
    def create_collection(self, name):
        """Create a new directory"""
        provider = self.provider
        domain = provider.domain
        access_token = provider.access_token
        
        # Build path parts
        dir_path = os.path.join(self.path, name).replace('\\', '/').lstrip('/')
        path_parts = dir_path.split('/') if dir_path else []
        parent_parts = path_parts[:-1] if len(path_parts) > 1 else []
        
        try:
            response = requests.post(
                f"https://{domain}/api/create-file",
                headers={
                    'Cookie': f'access_token={access_token}',
                    'Origin': f'https://{domain}',
                    'Content-Type': 'application/json'
                },
                json={
                    'parentPathParts': parent_parts,
                    'name': name,
                    'type': 'directory',
                    'root': 'w'
                },
                timeout=10
            )
            
            if response.status_code == 200:
                # Clear cache
                if self.path in provider.cache:
                    del provider.cache[self.path]
                
                # Return new directory resource
                child_path = os.path.join(self.path, name).replace('\\', '/')
                dir_info = {"name": name, "type": "directory", "children": []}
                return ZoDirectory(child_path, self.environ, dir_info)
            else:
                print(f"Create directory failed: {response.status_code}")
                raise DAVError(HTTP_FORBIDDEN)
                
        except Exception as e:
            print(f"Error creating directory: {e}")
            raise DAVError(HTTP_FORBIDDEN)
    
    def delete_member(self, name):
        """Delete a member (file or directory)"""
        # Get the member first
        member = self.get_member(name)
        if member:
            return member.delete()
        return False


class ZoComputerProvider(DAVProvider):
    """WebDAV provider that connects to Zo Computer API"""
    
    def __init__(self, domain, access_token):
        super().__init__()
        self.domain = domain
        self.access_token = access_token
        self.cache = {}  # Simple cache for directory listings
    
    def get_directory_info(self, path):
        """Fetch directory information from Zo Computer API"""
        
        # Check cache first
        if path in self.cache:
            return self.cache[path]
        
        # Build API request
        path_param = path.lstrip('/') if path != '/' else ''
        
        if path == '/' or path == '':
            url = f"https://{self.domain}/api/workspace-tree?root=w&showHidden=false"
        else:
            url = f"https://{self.domain}/api/workspace-tree?root=w&path={path_param}&showHidden=false"
        
        try:
            response = requests.get(
                url,
                headers={
                    'Cookie': f'access_token={self.access_token}',
                    'Origin': f'https://{self.domain}'
                },
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                self.cache[path] = data
                return data
            else:
                print(f"API error: {response.status_code} for {url}")
                return None
                
        except Exception as e:
            print(f"Error fetching directory info: {e}")
            return None
    
    def get_resource_inst(self, path, environ):
        """Return a DAVResource instance for the given path"""
        
        # Normalize path
        path = path.rstrip('/')
        if not path:
            path = '/'
        
        # Handle root directory
        if path == '/':
            root_info = self.get_directory_info('/')
            if root_info:
                return ZoDirectory('/', environ, root_info)
            return None
        
        # Get parent directory
        parent_path = os.path.dirname(path)
        if not parent_path:
            parent_path = '/'
        
        parent_info = self.get_directory_info(parent_path)
        if not parent_info:
            return None
        
        # Find the resource in parent's children
        name = os.path.basename(path)
        children = parent_info.get("children", [])
        
        for child in children:
            if child["name"] == name:
                if child["type"] == "directory":
                    dir_info = self.get_directory_info(path)
                    if dir_info:
                        return ZoDirectory(path, environ, dir_info)
                else:
                    return ZoFile(path, environ, child)
        
        return None


def load_config():
    """Load configuration from zo-chat config file"""
    config_path = os.path.expanduser("~/.config/zo-chat/config")
    
    if not os.path.exists(config_path):
        print(f"Error: Config file not found at {config_path}")
        print("Please run 'zochat' first to set up your credentials")
        sys.exit(1)
    
    try:
        with open(config_path, 'r') as f:
            lines = f.readlines()
            
        config = {}
        for line in lines:
            line = line.strip()
            if '=' in line and not line.startswith('#'):
                key, value = line.split('=', 1)
                config[key] = value.strip('"').strip("'")
        
        return config
    except Exception as e:
        print(f"Error reading config: {e}")
        sys.exit(1)


def main():
    """Start the WebDAV server"""
    
    # Load credentials
    config = load_config()
    domain = config.get('DOMAIN', 'zo.computer')
    access_token = config.get('ACCESS_TOKEN')
    
    if not access_token:
        print("Error: ACCESS_TOKEN not found in config")
        sys.exit(1)
    
    # Find an available port
    import socket
    def find_free_port(start_port=9999, max_attempts=100):
        for port in range(start_port, start_port + max_attempts):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.bind(('0.0.0.0', port))
                sock.close()
                return port
            except OSError:
                continue
        return None
    
    port = find_free_port()
    if not port:
        print("Error: Could not find an available port")
        sys.exit(1)
    
    print(f"Starting WebDAV server for {domain}...")
    print(f"Server will run on http://localhost:{port}")
    print()
    print("Mount instructions:")
    print(f"  macOS:   mkdir ~/zoMount && mount_webdav http://localhost:{port} ~/zoMount")
    print(f"  Linux:   mkdir ~/zoMount && mount -t davfs http://localhost:{port} ~/zoMount")
    print(f"  Windows: net use Z: http://localhost:{port}")
    print()
    print("Press Ctrl+C to stop the server")
    print()
    
    # Create provider
    provider = ZoComputerProvider(domain, access_token)
    
    # Configure WebDAV app
    config = {
        "provider_mapping": {
            "/": provider
        },
        "host": "0.0.0.0",
        "port": port,
        "verbose": 1,
        # Disable HTTP authentication - we handle auth via cookies internally
        "http_authenticator": {
            "domain_controller": None
        },
        "simple_dc": {
            "user_mapping": {
                "*": True  # Allow anonymous access
            }
        }
    }
    
    # Start server
    app = WsgiDAVApp(config)
    
    try:
        from cheroot import wsgi
        server = wsgi.Server(
            bind_addr=("0.0.0.0", port),
            wsgi_app=app
        )
        server.start()
    except KeyboardInterrupt:
        print("\nShutting down server...")
    except Exception as e:
        print(f"Error starting server: {e}")
        print("\nTry installing dependencies:")
        print("  pip install wsgidav cheroot requests")
        sys.exit(1)


if __name__ == "__main__":
    main()
